---

## name: 37d-c4 description

# 37d‑c4 — Pobieranie obrazów z ChatGPT na TODOIT (Properties)

## Wejście i założenia

- **Na wejsciu musi być podany BOOK_FOLDER (przykład: 0009_fahrenheit_451)** - jeśli nie ma, zakończ działanie z odpowiednim komunikatem
- **SOURCE_LIST**: `[BOOK_FOLDER]` (lista źródłowa z systemem properties)
- **Właściwości listy SOURCE**:
  - `book_folder = [BOOK_FOLDER]`
  - `project_id = g-p-...` (ID projektu ChatGPT)
- **Właściwości pozycji w SOURCE**:
  - `thread_id = ...` (ID czatu dla danej sceny)
  - `image_generated = completed|pending|in_progress|failed` (status generowania)
  - `image_downloaded = completed|pending|in_progress|failed` (status pobierania)
- **Nazewnictwo plików**: `[BOOK_FOLDER]_scene_[NN].png`, `[BOOK_FOLDER]_scene_[NN]_a.png`, ...

> Jeśli nie masz `project_id` lub `thread_id`, zatrzymaj się i napraw stan w 37d‑a3.

NIE uZywaj playwright-show-browser

## Algorytm (Properties)

### 0) Ustal kontekst

```javascript
// Wejście operacyjne
const SOURCE_LIST = "[BOOK_FOLDER]";

// Właściwości listy źródłowej
const bookFolder = await mcp__todoit__todo_get_list_property({
  list_key: SOURCE_LIST, property_key: "book_folder"
});
const projectId = await mcp__todoit__todo_get_list_property({
  list_key: SOURCE_LIST, property_key: "project_id"
});
if (!bookFolder || !projectId) { throw new Error("Brak book_folder albo project_id"); }
```

### 1) Pobierz następne zadanie do pobrania

```javascript
// OPTYMALIZACJA: Pobierz wszystkie properties zadań z statusem pending/in_progress
const allItemsProperties = await mcp__todoit__todo_get_all_items_properties({
  list_key: SOURCE_LIST,
  status: "in_progress"  // zadania w trakcie (będziemy filtrować po properties)
});

if (!allItemsProperties.success || allItemsProperties.count === 0) {
  console.log("Brak zadań w liście"); 
  return; 
}

// Znajdź pierwsze zadanie gotowe do pobrania (image_downloaded=pending + image_generated=completed)
let nextTask = null;
let threadId = null;

for (const itemProps of allItemsProperties.properties) {
  const properties = itemProps.properties;
  
  // Sprawdź czy image_downloaded=pending i image_generated=completed
  const downloadStatus = properties.find(p => p.property_key === "image_downloaded")?.property_value;
  const generateStatus = properties.find(p => p.property_key === "image_generated")?.property_value;
  const threadIdProperty = properties.find(p => p.property_key === "thread_id")?.property_value;
  
  if (downloadStatus === "pending" && generateStatus === "completed" && threadIdProperty) {
    nextTask = { item_key: itemProps.item_key };
    threadId = threadIdProperty;
    break;
  }
}

if (!nextTask) {
  console.log("Brak zadań gotowych do pobrania (pending download + completed generation)"); 
  return; 
}

const sceneKey = nextTask.item_key;          // np. "item_0012" 
if (!threadId) {
  await mcp__todoit__todo_set_item_property({
    list_key: SOURCE_LIST, item_key: sceneKey, 
    property_key: "image_downloaded", property_value: "failed"
  });
  throw new Error(`Brak thread_id dla ${sceneKey}`);
}

const chatUrl = `https://chatgpt.com/g/${projectId.property_value}/c/${threadId}`;
console.log(`Pobieranie obrazu dla zadania: ${sceneKey}, Thread: ${threadId}`);
```

### 2) Wejdź w czat i zrzutuj wszystkie obrazy

```javascript
await mcp__playwright-headless__browser_navigate({ url: chatUrl });
await mcp__playwright-headless__browser_wait_for(time: 5);
await mcp__playwright-headless__browser_snapshot();

// Pobieranie: pojedyncze odpowiedzi
await mcp__playwright-headless__browser_click({ element: "Download this image button" });

// Pobieranie: odpowiedzi wielokrotne (Previous/Next)
let moved;
do {
  // Spróbuj cofnąć do pierwszej odpowiedzi i pobrać
  moved = await mcp__playwright-headless__browser_evaluate({
    function: `() => {
      const buttons = Array.from(document.querySelectorAll('button'));
      const prev = buttons.find(b => (b.getAttribute('aria-label')||'').includes('Previous response'));
      if (prev && !prev.disabled) { prev.click(); return true; }
      return false;
    }`
  });
  await mcp__playwright-headless__browser_click({ element: "Download this image button" });
} while (moved === true);

```

### 3) Przenieś i nazwij pliki

```bash
# Pobierz opis zadania aby wyciągnąć numer sceny
const itemData = await mcp__todoit__todo_get_item({
  list_key: SOURCE_LIST, item_key: sceneKey
});
const itemContent = itemData.item.content;

# Miejsce zrzutów (zależnie od serwera MCP)
ls -t /tmp/playwright-mcp-files/headless/ChatGPT-Image*.png || true

SCENE_NUM=$(echo "$itemContent" | sed -E 's/.*scene_([0-9]{2})\.yaml.*/\1/')
BASE="${bookFolder}_scene_${SCENE_NUM}"
DEST_DIR="/home/xai/DEV/37degrees/books/${bookFolder}/generated"
mkdir -p "$DEST_DIR"

# Nie nadpisuj. Doklejaj sufiksy _a _b ...
move_one() {
  src="$1"; name="$2"; idx=0; out="${DEST_DIR}/${name}.png"
  while [ -e "$out" ]; do idx=$((idx+1)); suf=$(printf "_%c" $((96+idx))); out="${DEST_DIR}/${name}${suf}.png"; done
  mv -n "$src" "$out" && echo "$out"
}

# Przenieś wszystkie pobrane pliki
DOWNLOADS=(/tmp/playwright-mcp-files/headless/ChatGPT-Image*.png)
SAVED=""
for f in "${DOWNLOADS[@]}"; do p=$(move_one "$f" "$BASE"); [ -n "$p" ] && SAVED+="$p\n"; done
```

### 4) Aktualizacje w TODOIT

```javascript
// Oznacz pobieranie jako ukończone
await mcp__todoit__todo_set_item_property({
  list_key: SOURCE_LIST, item_key: sceneKey, 
  property_key: "image_downloaded", property_value: "completed"
});

// Sprawdź czy wszystkie etapy ukończone i ustaw status główny
// Użyj już pobranych właściwości zamiast dodatkowego wywołania
const generateStatus = properties.find(p => p.property_key === "image_generated")?.property_value;
if (generateStatus === "completed") {
  await mcp__todoit__todo_update_item_status({
    list_key: SOURCE_LIST, item_key: sceneKey, status: "completed"
  });
}
```

### 5) Sprzątanie

```javascript
await mcp__playwright-headless__browser_close();
```

## Funkcje pomocnicze dla systemu properties

### Filtrowanie zadań gotowych do pobrania

```javascript
// OPTYMALIZOWANA funkcja do znajdowania następnego zadania do pobrania
async function findNextDownloadTask(sourceList) {
  // Pobierz wszystkie properties jednym wywołaniem
  const allItemsProperties = await mcp__todoit__todo_get_all_items_properties({
    list_key: sourceList,
    status: "in_progress"  // zadania w trakcie
  });
  
  if (!allItemsProperties.success || allItemsProperties.count === 0) {
    return null;
  }
  
  // Znajdź pierwsze zadanie gotowe do pobrania
  for (const itemProps of allItemsProperties.properties) {
    const properties = itemProps.properties;
    
    const downloadStatus = properties.find(p => p.property_key === "image_downloaded")?.property_value;
    const generateStatus = properties.find(p => p.property_key === "image_generated")?.property_value;
    const threadIdProperty = properties.find(p => p.property_key === "thread_id")?.property_value;
    
    if (downloadStatus === "pending" && generateStatus === "completed" && threadIdProperty) {
      return {
        item_key: itemProps.item_key,
        thread_id: threadIdProperty,
        download_status: downloadStatus,
        generate_status: generateStatus
      };
    }
  }
  
  return null;
}
```

### Status główny na podstawie properties

```javascript
// OPTYMALIZOWANA logika kombinacji properties → status główny
async function syncMainStatus(sourceList, itemKey) {
  // Pobierz wszystkie properties dla konkretnego zadania
  const allItemsProperties = await mcp__todoit__todo_get_all_items_properties({
    list_key: sourceList,
    status: "in_progress"
  });
  
  // Znajdź properties dla konkretnego itemKey
  const itemProps = allItemsProperties.properties?.find(item => item.item_key === itemKey);
  if (!itemProps) {
    throw new Error(`Zadanie ${itemKey} nie znalezione`);
  }
  
  const properties = itemProps.properties;
  const genStatus = properties.find(p => p.property_key === "image_generated")?.property_value || "pending";
  const dlStatus = properties.find(p => p.property_key === "image_downloaded")?.property_value || "pending";
  
  let mainStatus;
  if (genStatus === "failed" || dlStatus === "failed") {
    mainStatus = "failed";
  } else if (genStatus === "completed" && dlStatus === "completed") {
    mainStatus = "completed";
  } else if (genStatus === "pending" && dlStatus === "pending") {
    mainStatus = "pending";
  } else {
    mainStatus = "in_progress";
  }
  
  await mcp__todoit__todo_update_item_status({
    list_key: sourceList, item_key: itemKey, status: mainStatus
  });
}
```

## Przykłady użycia funkcji MCP

### Znajdowanie zadań gotowych do pobrania

```javascript
// Znajdź pierwsze zadanie gotowe do pobrania dla konkretnej książki
const nextTask = await mcp__todoit__todo_find_items_by_property({
  list_key: "0037_wuthering_heights",
  property_key: "image_downloaded", 
  property_value: "pending",
  limit: 1
});

if (nextTask.success && nextTask.count > 0) {
  console.log(`Znaleziono zadanie do pobrania: ${nextTask.items[0].item_key}`);
}

// Sprawdź wszystkie zadania z ukończonym generowaniem
const generatedTasks = await mcp__todoit__todo_find_items_by_property({
  list_key: "0037_wuthering_heights",
  property_key: "image_generated", 
  property_value: "completed"
});

console.log(`Zadania z ukończonym generowaniem: ${generatedTasks.count}`);
```

### Monitoring stanu zadań

```javascript
// Sprawdź wszystkie zadania w trakcie pobierania
const inProgressDownloads = await mcp__todoit__todo_find_items_by_property({
  list_key: "0037_wuthering_heights",
  property_key: "image_downloaded", 
  property_value: "in_progress"
});

// Sprawdź zadania które się nie powiodły
const failedTasks = await mcp__todoit__todo_find_items_by_property({
  list_key: "0037_wuthering_heights",
  property_key: "image_downloaded", 
  property_value: "failed"
});

console.log(`W trakcie: ${inProgressDownloads.count}, Nieudane: ${failedTasks.count}`);
```

### Debugowanie właściwości zadań

```javascript
// OPTYMALIZOWANE: Pobierz wszystkie właściwości jednym wywołaniem
const allItemsProperties = await mcp__todoit__todo_get_all_items_properties({
  list_key: "0037_wuthering_heights"
});

// Znajdź właściwości dla konkretnego zadania
const sceneProps = allItemsProperties.properties?.find(item => item.item_key === "scene_01");
if (sceneProps) {
  const threadId = sceneProps.properties.find(p => p.property_key === "thread_id")?.property_value;
  const imageStatus = sceneProps.properties.find(p => p.property_key === "image_downloaded")?.property_value;
  
  console.log(`Scene 01 - Thread: ${threadId}, Status: ${imageStatus}`);
}
```
