---

## name: 37d-c4-todoit description: | Step 4 przepisany na TODOIT z systemem properties. Zero plikowych TODO. Całość na MCP: todoit + playwright-headless. Zakłada istnienie listy źródłowej [BOOK\_FOLDER] z własnościami: book\_folder, project\_id oraz właściwości thread\_id na pozycjach (nadane w 37d-a3). Pobiera obrazy dla pozycji gdzie image\_generated=completed ale image\_downloaded!=completed.

# 37d‑c4‑todoit — Pobieranie obrazów z ChatGPT na TODOIT (Properties)

## Wejście i założenia

- **Na wejsciu musi być podany BOOK_FOLDER (przykład: 0009_fahrenheit_451)** - jeśli nie ma, zakończ działanie z odpowiednim komunikatem
- **SOURCE\_LIST**: `[BOOK_FOLDER]` (lista źródłowa z systemem properties)
- **Właściwości listy SOURCE**:
  - `book_folder = [BOOK_FOLDER]`
  - `project_id = g-p-...` (ID projektu ChatGPT)
- **Właściwości pozycji w SOURCE**:
  - `thread_id = ...` (ID czatu dla danej sceny)
  - `image_generated = completed|pending|in_progress|failed` (status generowania)
  - `image_downloaded = completed|pending|in_progress|failed` (status pobierania)
- **Nazewnictwo plików**: `[BOOK_FOLDER]_scene_[NN].png`, `[BOOK_FOLDER]_scene_[NN]_a.png`, ...

> Jeśli nie masz `project_id` lub `thread_id`, zatrzymaj się i napraw stan w 37d‑a3.

## Algorytm (Properties)

### 0) Ustal kontekst

```javascript
// Wejście operacyjne
const SOURCE_LIST = "[BOOK_FOLDER]";

// Właściwości listy źródłowej
const bookFolder = await mcp__todoit__todo_get_list_property({
  list_key: SOURCE_LIST, property_key: "book_folder"
});
const projectId = await mcp__todoit__todo_get_list_property({
  list_key: SOURCE_LIST, property_key: "project_id"
});
if (!bookFolder || !projectId) { throw new Error("Brak book_folder albo project_id"); }
```

### 1) Pobierz następne zadanie do pobrania

```javascript
// Znajdź zadania gdzie image_generated=completed ale image_downloaded!=completed
const allItems = await mcp__todoit__todo_get_list_items({ list_key: SOURCE_LIST });
const nextItem = allItems.items.find(async item => {
  const imageGenerated = await mcp__todoit__todo_get_item_property({
    list_key: SOURCE_LIST, item_key: item.item_key, property_key: "image_generated"
  });
  const imageDownloaded = await mcp__todoit__todo_get_item_property({
    list_key: SOURCE_LIST, item_key: item.item_key, property_key: "image_downloaded"
  });
  
  return imageGenerated?.property_value === "completed" && 
         imageDownloaded?.property_value !== "completed";
});

if (!nextItem) { console.log("Brak zadań gotowych do pobrania"); return; }

// Oznacz jako w trakcie pobierania
await mcp__todoit__todo_set_item_property({
  list_key: SOURCE_LIST, item_key: nextItem.item_key, 
  property_key: "image_downloaded", property_value: "in_progress"
});

const sceneKey = nextItem.item_key;          // np. "scene_01"
const threadId = await mcp__todoit__todo_get_item_property({
  list_key: SOURCE_LIST, item_key: sceneKey, property_key: "thread_id"
});
if (!threadId?.property_value) {
  await mcp__todoit__todo_set_item_property({
    list_key: SOURCE_LIST, item_key: sceneKey, 
    property_key: "image_downloaded", property_value: "failed"
  });
  throw new Error(`Brak thread_id dla ${sceneKey}`);
}
const chatUrl = `https://chatgpt.com/g/${projectId}/c/${threadId.property_value}`;
```

### 2) Wejdź w czat i zrzutuj wszystkie obrazy

```javascript
await mcp__playwright-headless__browser_navigate({ url: chatUrl });
await mcp__playwright-headless__browser_snapshot();

// Pobieranie: pojedyncze odpowiedzi
await mcp__playwright-headless__browser_click({ element: "Download this image button" });

// Pobieranie: odpowiedzi wielokrotne (Previous/Next)
let moved;
do {
  // Spróbuj cofnąć do pierwszej odpowiedzi i pobrać
  moved = await mcp__playwright-headless__browser_evaluate({
    function: `() => {
      const buttons = Array.from(document.querySelectorAll('button'));
      const prev = buttons.find(b => (b.getAttribute('aria-label')||'').includes('Previous response'));
      if (prev && !prev.disabled) { prev.click(); return true; }
      return false;
    }`
  });
  await mcp__playwright-headless__browser_click({ element: "Download this image button" });
} while (moved === true);

```

### 3) Przenieś i nazwij pliki

```bash
# Miejsce zrzutów (zależnie od serwera MCP)
ls -t /tmp/playwright-mcp-files/headless/ChatGPT-Image*.png || true

SCENE_NUM=$(echo "$sceneKey" | sed -E 's/scene_([0-9]{2})/\1/')
BASE="${bookFolder}_scene_${SCENE_NUM}"
DEST_DIR="/home/xai/DEV/37degrees/books/${bookFolder}/generated"
mkdir -p "$DEST_DIR"

# Nie nadpisuj. Doklejaj sufiksy _a _b ...
move_one() {
  src="$1"; name="$2"; idx=0; out="${DEST_DIR}/${name}.png"
  while [ -e "$out" ]; do idx=$((idx+1)); suf=$(printf "_%c" $((96+idx))); out="${DEST_DIR}/${name}${suf}.png"; done
  mv -n "$src" "$out" && echo "$out"
}

# Przenieś wszystkie pobrane pliki
DOWNLOADS=(/tmp/playwright-mcp-files/headless/ChatGPT-Image*.png)
SAVED=""
for f in "${DOWNLOADS[@]}"; do p=$(move_one "$f" "$BASE"); [ -n "$p" ] && SAVED+="$p\n"; done
```

### 4) Aktualizacje w TODOIT

```javascript
// Oznacz pobieranie jako ukończone
await mcp__todoit__todo_set_item_property({
  list_key: SOURCE_LIST, item_key: sceneKey, 
  property_key: "image_downloaded", property_value: "completed"
});

// Sprawdź czy wszystkie etapy ukończone i ustaw status główny
const imageGenerated = await mcp__todoit__todo_get_item_property({
  list_key: SOURCE_LIST, item_key: sceneKey, property_key: "image_generated"
});
if (imageGenerated?.property_value === "completed") {
  await mcp__todoit__todo_update_item_status({
    list_key: SOURCE_LIST, item_key: sceneKey, status: "completed"
  });
}
```

### 5) Sprzątanie

```javascript
await mcp__playwright-headless__browser_close();
```

## Funkcje pomocnicze dla systemu properties

### Filtrowanie zadań gotowych do pobrania

```javascript
// Funkcja do znajdowania następnego zadania do pobrania
async function findNextDownloadTask(sourceList) {
  const allItems = await mcp__todoit__todo_get_list_items({ list_key: sourceList });
  
  for (const item of allItems.items) {
    const imageGenerated = await mcp__todoit__todo_get_item_property({
      list_key: sourceList, item_key: item.item_key, property_key: "image_generated"
    });
    const imageDownloaded = await mcp__todoit__todo_get_item_property({
      list_key: sourceList, item_key: item.item_key, property_key: "image_downloaded"
    });
    
    // Gotowe do pobrania: generated=completed AND downloaded!=completed
    if (imageGenerated?.property_value === "completed" && 
        imageDownloaded?.property_value !== "completed") {
      return item;
    }
  }
  return null;
}
```

### Status główny na podstawie properties

```javascript
// Logika kombinacji properties → status główny
async function syncMainStatus(sourceList, itemKey) {
  const imageGenerated = await mcp__todoit__todo_get_item_property({
    list_key: sourceList, item_key: itemKey, property_key: "image_generated"
  });
  const imageDownloaded = await mcp__todoit__todo_get_item_property({
    list_key: sourceList, item_key: itemKey, property_key: "image_downloaded"
  });
  
  const genStatus = imageGenerated?.property_value || "pending";
  const dlStatus = imageDownloaded?.property_value || "pending";
  
  let mainStatus;
  if (genStatus === "failed" || dlStatus === "failed") {
    mainStatus = "failed";
  } else if (genStatus === "completed" && dlStatus === "completed") {
    mainStatus = "completed";
  } else if (genStatus === "pending" && dlStatus === "pending") {
    mainStatus = "pending";
  } else {
    mainStatus = "in_progress";
  }
  
  await mcp__todoit__todo_update_item_status({
    list_key: sourceList, item_key: itemKey, status: mainStatus
  });
}
```
