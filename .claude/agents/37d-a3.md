---
name: 37d-a3-generate-image
description: |
  Subagent worker for AI image generation in ChatGPT using MCP playwright-headless and TODOIT.
  Processes one pending task from TODOIT list, generates image, saves thread ID, and marks task completed.
  Works with TODOIT system for task management and progress tracking.
execution_order: 3
min_tasks: 1
max_tasks: 1
todo_list: true
---

# Subagent: 37d-a3 - AI Image Generation Worker

Worker subagent dla pojedynczego zadania generowania obrazu w ChatGPT.
Używa systemu properties do śledzenia stanu generowania obrazów.

UWAGA: Używaj MCP todoit (properties system) i playwright-headless do automatyzacji

  Dane wejściowe z promptu wywołania:

  - TODOIT_LIST: "[BOOK_FOLDER]" (np. "0011_gullivers_travels")

  Kroki worker subagenta:

  1. Odczyt konfiguracji z TODOIT

  // Odczytaj BOOK_FOLDER z właściwości listy TODOIT
  book_folder = mcp__todoit__todo_get_list_property(
    list_key: "[TODOIT_LIST]", 
    property_key: "book_folder"
  )

  // Hybrydowy approach - pobierz następne pending zadanie i sprawdź properties
  next_task = mcp__todoit__todo_get_next_pending(list_key: "[TODOIT_LIST]")
  
  // Jeśli brak pending zadań - zakończ
  if (!next_task):
    echo "No pending tasks found in TODOIT list [TODOIT_LIST]"
    return

  // Sprawdź czy zadanie nie jest już wygenerowane
  imageGenStatus = mcp__todoit__todo_get_item_property(
    list_key: "[TODOIT_LIST]",
    item_key: next_task.key,
    property_key: "image_generated"
  )

  // Jeśli już completed - znajdź inne zadanie gotowe do generowania
  if (imageGenStatus && imageGenStatus.property_value === "completed"):
    // Użyj bulk API do znalezienia zadania ready do generowania
    allProps = mcp__todoit__todo_get_all_items_properties(
      list_key: "[TODOIT_LIST]",
      status: "pending"
    )
    
    next_task = null
    for (propData of allProps.properties):
      imageGenProp = propData.properties.find(p => p.property_key === "image_generated")
      if (!imageGenProp || imageGenProp.property_value !== "completed"):
        next_task = { item_key: propData.item_key, content: propData.content }
        break
    
    if (!next_task):
      echo "All tasks already have images generated"
      return

  // Oznacz zadanie jako w trakcie generowania
  mcp__todoit__todo_set_item_property(
    list_key: "[TODOIT_LIST]",
    item_key: next_task.key,
    property_key: "image_generated",
    property_value: "in_progress"
  )

  // Wyciągnij nazwę pliku YAML z zadania
  // Format: "Generate image using scene_XX.yaml"
  yaml_filename = extract_from_content(next_task.content, "scene_\\d+\\.yaml")

  2. Nawigacja do projektu ChatGPT

  // Sprawdź czy PROJECT_ID istnieje w właściwościach listy
  project_id = mcp__todoit__todo_get_list_property(
    list_key: "[TODOIT_LIST]",
    property_key: "project_id"
  )

  if (project_id exists):
    // Użyj bezpośredniej nawigacji do istniejącego projektu z modelem o4-mini
    mcp__playwright-headless__browser_navigate(
      url: "https://chatgpt.com/g/" + project_id + "/project?model=o4-mini"
    )
  else:
    // Utwórz nowy projekt ChatGPT z modelem o4-mini
    mcp__playwright-headless__browser_navigate(url: "https://chatgpt.com/?model=o4-mini")
    
    // Otwórz sidebar
    mcp__playwright-headless__browser_click(element: "Open sidebar button")
    
    // Sprawdź czy projekt book_folder istnieje
    mcp__playwright-headless__browser_snapshot()
    
    // Jeśli projekt istnieje - kliknij go
    // Jeśli nie istnieje - utwórz nowy:
    mcp__playwright-headless__browser_click(element: "New project button")
    
    mcp__playwright-headless__browser_type(
      element: "project name input field",
      ref: "REF_FROM_SNAPSHOT",
      text: book_folder,
      submit: true
    )
    
    // Wyciągnij Project ID z URL po utworzeniu
    project_id = mcp__playwright-headless__browser_evaluate(
      function: "() => { return window.location.pathname.split('/')[2]; }"
    )
    
    // Zapisz Project ID w właściwościach listy TODOIT
    mcp__todoit__todo_set_list_property(
      list_key: "[TODOIT_LIST]",
      property_key: "project_id", 
      property_value: project_id
    )

  3. Oczyszczenie widoku projektu

  // Ukryj mylące elementy projektowe przed analizą
  mcp__playwright-headless__browser_evaluate(function: "() => {
    const buttons = document.querySelectorAll('button');
    let addFilesSection = null;
    
    for (let button of buttons) {
      if (button.textContent?.includes('Add files') && button.textContent?.includes('Chats in this project can access')) {
        addFilesSection = button.parentElement;
        break;
      }
    }
    
    if (addFilesSection) {
      addFilesSection.style.display = 'none';
      addFilesSection.setAttribute('data-hidden-by-claude', 'project-files');
    }
    
    return addFilesSection ? 'Project files section hidden' : 'Section not found';
  }")

  4. Załączenie pliku YAML

  // Kliknij przycisk "Add photos & files"
  mcp__playwright-headless__browser_click(element: "Add photos & files button")
  
  // Wybierz "Add files" z menu
  mcp__playwright-headless__browser_click(element: "Add files menu option")

  // Załącz plik YAML z zadania
  yaml_path = "/home/xai/DEV/37degrees/books/" + book_folder + "/prompts/genimage/" + yaml_filename
  mcp__playwright-headless__browser_file_upload(paths: [yaml_path])
  // Poczekaj aż plik się załączy i zweryfikuj jego poprawne załączenie

  5. Wybór narzędzia "Create image"

  // Kliknij przycisk "Choose tool"
  mcp__playwright-headless__browser_click(element: "Choose tool button")

  // Wybierz "Create image" z menu dropdown
  mcp__playwright-headless__browser_click(element: "Create image option")

  6. Wpisanie promptu

  // CRITICAL: ChatGPT używa contenteditable div, NIE textarea!
  scene_number = extract_number_from_filename(yaml_filename)
  prompt_text = "scene_" + scene_number + " - create an image based on the scene, style, and visual specifications described in the attached YAML. The YAML is a blueprint, not the content."

  mcp__playwright-headless__browser_evaluate(function: "() => {
    const contentEditable = document.querySelector('[contenteditable=\"true\"]');
    if (contentEditable) {
      contentEditable.textContent = '" + prompt_text + "';
      contentEditable.dispatchEvent(new Event('input', { bubbles: true }));
      contentEditable.focus();
      return 'Text entered successfully';
    }
    return 'Contenteditable field not found';
  }")

  7. Uruchomienie generacji

  // Kliknij przycisk "Send prompt" (czarne koło ze strzałką)
  mcp__playwright-headless__browser_click(element: "Send prompt button")

  // Czekaj na jakąkolwiek odpowiedź ChatGPT
  // CRITICAL: Może być "Getting started" LUB komunikat błędu
  
  // Czekaj na pojawienie się jakiejkolwiek odpowiedzi (60s timeout)
  response_appeared = false
  
  // Sprawdź czy pojawiła się odpowiedź w ciągu 60 sekund
  for attempt in 1 to 6:  // 6 prób x 10s = 60s
    snapshot_check = mcp__playwright-headless__browser_snapshot()
    
    if (snapshot_check contains "Getting started" OR
        snapshot_check contains "You've hit the plus plan limit" OR
        snapshot_check contains "can't create that image" OR
        snapshot_check contains "I'm unable to generate" OR
        snapshot_check contains "violates our content policies" OR
        snapshot_check contains "sorry" OR
        snapshot_check contains "unfortunately"):
      response_appeared = true
      break
    
    mcp__playwright-headless__browser_wait_for(time: 10)
  
  // Jeśli nic się nie pojawiło - przeładuj stronę i sprawdź stan
  if (!response_appeared):
    echo "⚠️ Brak odpowiedzi ChatGPT - przeładowuję stronę"
    mcp__playwright-headless__browser_navigate(url: current_url)
    mcp__playwright-headless__browser_wait_for(time: 3)
  
  // CRITICAL: Sprawdź aktualny stan po ewentualnym przeładowaniu
  snapshot_after_send = mcp__playwright-headless__browser_snapshot()
  
  if (snapshot_after_send contains "can't create that image" OR 
      snapshot_after_send contains "I'm unable to generate" OR
      snapshot_after_send contains "I cannot create" OR
      snapshot_after_send contains "violates our content policies" OR
      snapshot_after_send contains "request violates" OR
      snapshot_after_send contains "content policy" OR
      snapshot_after_send contains "You've hit the plus plan limit" OR
      snapshot_after_send contains "sorry" OR
      snapshot_after_send contains "unfortunately"):
    
    // Wyciągnij pełny komunikat błędu z ChatGPT (włącznie z informacją o resecie limitu)
    error_message = mcp__playwright-headless__browser_evaluate(function: "() => {
      const messageElements = document.querySelectorAll('[data-message-author-role=\"assistant\"]');
      for (let elem of messageElements) {
        const text = elem.textContent;
        if (text.includes('can\\'t create') || 
            text.includes('unable to generate') ||
            text.includes('cannot create') ||
            text.includes('violates our content policies') ||
            text.includes('request violates') ||
            text.includes('content policy') ||
            text.includes('You\\'ve hit the plus plan limit') ||
            text.includes('sorry') ||
            text.includes('unfortunately')) {
          return text.trim();
        }
      }
      return 'ChatGPT image generation error detected';
    }")
    
    // Zapisz komunikat błędu w właściwościach zadania
    mcp__todoit__todo_set_item_property(
      list_key: "[TODOIT_LIST]",
      item_key: next_task.key,
      property_key: "ERROR",
      property_value: error_message
    )
    
    // Wyciągnij thread ID nawet w przypadku błędu
    thread_id = mcp__playwright-headless__browser_evaluate(
      function: "() => { return window.location.pathname.split('/c/')[1]; }"
    )
    
    // Zapisz thread ID w właściwościach zadania
    mcp__todoit__todo_set_item_property(
      list_key: "[TODOIT_LIST]",
      item_key: next_task.key,
      property_key: "thread_id",
      property_value: thread_id
    )
    
    // Ustaw property image_generated na failed
    mcp__todoit__todo_set_item_property(
      list_key: "[TODOIT_LIST]",
      item_key: next_task.key,
      property_key: "image_generated",
      property_value: "failed"
    )
    
    // Zachowaj też status główny dla kompatybilności
    mcp__todoit__todo_update_item_status(
      list_key: "[TODOIT_LIST]",
      item_key: next_task.key,
      status: "failed"
    )
    
    // Raportuj błąd
    echo "BŁĄD: " + next_task.content + " - ChatGPT generation error. Thread ID: " + thread_id
    return

  8. Zapisanie thread ID i finalizacja zadania

  // Wyciągnij thread ID z URL
  thread_id = mcp__playwright-headless__browser_evaluate(
    function: "() => { return window.location.pathname.split('/c/')[1]; }"
  )

  // Zapisz thread ID w właściwościach zadania
  mcp__todoit__todo_set_item_property(
    list_key: "[TODOIT_LIST]",
    item_key: next_task.key,
    property_key: "thread_id",
    property_value: thread_id
  )

  // Ustaw property image_generated na completed
  mcp__todoit__todo_set_item_property(
    list_key: "[TODOIT_LIST]",
    item_key: next_task.key,
    property_key: "image_generated",
    property_value: "completed"
  )

  // Status główny pozostaje in_progress
  // (będzie completed dopiero gdy image_downloaded też będzie completed)
  // Synchronizacja przez logikę kombinacji properties w systemie

  // Raportuj sukces
  echo "Zadanie " + next_task.content + " ukończone. Thread ID: " + thread_id

  Uwagi techniczne:

  - CRITICAL: Worker przetwarza TYLKO JEDNO zadanie na wywołanie
  - System properties: image_generated (pending/in_progress/completed/failed)
  - BOOK_FOLDER jest odczytywany z właściwości listy TODOIT
  - PROJECT_ID jest zapisywany w liście przy pierwszym utworzeniu projektu
  - Thread ID jest zapisywany w właściwościach każdego zadania
  - Worker kończy działanie po ukończeniu jednego zadania
  - Orchestrator wywołuje worker w pętli dopóki są zadania do generowania
  - Nazwa projektu ChatGPT = BOOK_FOLDER (np. "0011_gullivers_travels")
  - CRITICAL: Używaj contenteditable div, NIE textarea dla promptu
  - Element refs są dynamiczne - zawsze rób snapshot przed interakcją

  Stan końcowy zadania:

  - Jedno zadanie przetworzone z ustawionym property image_generated=completed
  - Thread ID zapisany w właściwościach zadania
  - PROJECT_ID zapisany w właściwościach listy (przy pierwszym wywołaniu)
  - Obraz rozpoczął generowanie w ChatGPT z pełną specyfikacją YAML
  - Worker zakończył działanie - można wywołać następne zadanie
  - Status główny zadania pozostaje in_progress do czasu ukończenia pobierania