---
name: 37d-a3-generate-image
description: |
  Subagent worker for AI image generation in ChatGPT using MCP playwright-headless and TODOIT.
  Processes one pending task from TODOIT list, generates image, saves thread ID, and marks task completed.
  Works with TODOIT system for task management and progress tracking.
execution_order: 3
min_tasks: 1
max_tasks: 1
todo_list: true
---

# Subagent: 37d-a3 - AI Image Generation Worker

Worker subagent dla pojedynczego zadania generowania obrazu w ChatGPT

UWAGA: Używaj MCP todoit i playwright-headless do automatyzacji

  Dane wejściowe z promptu wywołania:

  - TODOIT_LIST: "[BOOK_FOLDER]" (np. "0011_gullivers_travels")

  Kroki worker subagenta:

  1. Odczyt konfiguracji z TODOIT

  // Odczytaj BOOK_FOLDER z właściwości listy TODOIT
  book_folder = mcp__todoit__todo_get_list_property(
    list_key: "[TODOIT_LIST]", 
    property_key: "book_folder"
  )

  // Pobierz następne pending zadanie
  next_task = mcp__todoit__todo_get_next_pending(list_key: "[TODOIT_LIST]")
  
  // Jeśli brak pending zadań - zakończ
  if (!next_task):
    echo "No pending tasks found in TODOIT list [TODOIT_LIST]"
    return

  // Wyciągnij nazwę pliku YAML z zadania
  // Format: "Generate image using scene_XX.yaml"
  yaml_filename = extract_from_content(next_task.content, "scene_\\d+\\.yaml")

  2. Nawigacja do projektu ChatGPT

  // Sprawdź czy PROJECT_ID istnieje w właściwościach listy
  project_id = mcp__todoit__todo_get_list_property(
    list_key: "[TODOIT_LIST]",
    property_key: "project_id"
  )

  if (project_id exists):
    // Użyj bezpośredniej nawigacji do istniejącego projektu
    mcp__playwright-headless__browser_navigate(
      url: "https://chatgpt.com/g/" + project_id + "/project"
    )
  else:
    // Utwórz nowy projekt ChatGPT
    mcp__playwright-headless__browser_navigate(url: "https://chatgpt.com/")
    
    // Otwórz sidebar
    mcp__playwright-headless__browser_click(element: "Open sidebar button")
    
    // Sprawdź czy projekt book_folder istnieje
    mcp__playwright-headless__browser_snapshot()
    
    // Jeśli projekt istnieje - kliknij go
    // Jeśli nie istnieje - utwórz nowy:
    mcp__playwright-headless__browser_click(element: "New project button")
    
    mcp__playwright-headless__browser_type(
      element: "project name input field",
      ref: "REF_FROM_SNAPSHOT",
      text: book_folder,
      submit: true
    )
    
    // Wyciągnij Project ID z URL po utworzeniu
    project_id = mcp__playwright-headless__browser_evaluate(
      function: "() => { return window.location.pathname.split('/')[2]; }"
    )
    
    // Zapisz Project ID w właściwościach listy TODOIT
    mcp__todoit__todo_set_list_property(
      list_key: "[TODOIT_LIST]",
      property_key: "project_id", 
      property_value: project_id
    )

  3. Oczyszczenie widoku projektu

  // Ukryj mylące elementy projektowe przed analizą
  mcp__playwright-headless__browser_evaluate(function: "() => {
    const buttons = document.querySelectorAll('button');
    let addFilesSection = null;
    
    for (let button of buttons) {
      if (button.textContent?.includes('Add files') && button.textContent?.includes('Chats in this project can access')) {
        addFilesSection = button.parentElement;
        break;
      }
    }
    
    if (addFilesSection) {
      addFilesSection.style.display = 'none';
      addFilesSection.setAttribute('data-hidden-by-claude', 'project-files');
    }
    
    return addFilesSection ? 'Project files section hidden' : 'Section not found';
  }")

  4. Przygotowanie YAML do promptu

  yaml_path = "/home/xai/DEV/37degrees/books/" + book_folder + "/prompts/genimage/" + yaml_filename
  
  // Wczytaj zawartość pliku YAML
  yaml_content = Read(file_path: yaml_path)
  
  scene_number = extract_number_from_filename(yaml_filename)
  full_prompt = "scene_" + scene_number + " - create an image based on the yaml described below:\n\n" + yaml_content

  5. Wybór narzędzia "Create image"

  // Kliknij przycisk "Choose tool"
  mcp__playwright-headless__browser_click(element: "Choose tool button")

  // Wybierz "Create image" z menu dropdown
  mcp__playwright-headless__browser_click(element: "Create image option")

  6. Wpisanie promptu

  // CRITICAL: ChatGPT używa contenteditable div, NIE textarea!

  mcp__playwright-headless__browser_evaluate(function: "() => {
    const contentEditable = document.querySelector('[contenteditable=\"true\"]');
    if (contentEditable) {
      contentEditable.textContent = '" + full_prompt + "';
      contentEditable.dispatchEvent(new Event('input', { bubbles: true }));
      contentEditable.focus();
      return 'Full prompt with YAML entered successfully';
    }
    return 'Contenteditable field not found';
  }")

  7. Uruchomienie generacji

  // Kliknij przycisk "Send prompt" (czarne koło ze strzałką)
  mcp__playwright-headless__browser_click(element: "Send prompt button")

  // Czekaj na jakąkolwiek odpowiedź ChatGPT
  // CRITICAL: Może być "Getting started" LUB komunikat błędu
  
  // Czekaj na pojawienie się jakiejkolwiek odpowiedzi (60s timeout)
  response_appeared = false
  
  // Sprawdź czy pojawiła się odpowiedź w ciągu 60 sekund
  for attempt in 1 to 6:  // 6 prób x 10s = 60s
    snapshot_check = mcp__playwright-headless__browser_snapshot()
    
    if (snapshot_check contains "Getting started" OR
        snapshot_check contains "You've hit the plus plan limit" OR
        snapshot_check contains "can't create that image" OR
        snapshot_check contains "I'm unable to generate" OR
        snapshot_check contains "violates our content policies" OR
        snapshot_check contains "sorry" OR
        snapshot_check contains "unfortunately"):
      response_appeared = true
      break
    
    mcp__playwright-headless__browser_wait_for(time: 10)
  
  // Jeśli nic się nie pojawiło - przeładuj stronę i sprawdź stan
  if (!response_appeared):
    echo "⚠️ Brak odpowiedzi ChatGPT - przeładowuję stronę"
    mcp__playwright-headless__browser_navigate(url: current_url)
    mcp__playwright-headless__browser_wait_for(time: 3)
  
  // CRITICAL: Sprawdź aktualny stan po ewentualnym przeładowaniu
  snapshot_after_send = mcp__playwright-headless__browser_snapshot()
  
  if (snapshot_after_send contains "can't create that image" OR 
      snapshot_after_send contains "I'm unable to generate" OR
      snapshot_after_send contains "I cannot create" OR
      snapshot_after_send contains "violates our content policies" OR
      snapshot_after_send contains "request violates" OR
      snapshot_after_send contains "content policy" OR
      snapshot_after_send contains "You've hit the plus plan limit" OR
      snapshot_after_send contains "sorry" OR
      snapshot_after_send contains "unfortunately"):
    
    // Wyciągnij pełny komunikat błędu z ChatGPT (włącznie z informacją o resecie limitu)
    error_message = mcp__playwright-headless__browser_evaluate(function: "() => {
      const messageElements = document.querySelectorAll('[data-message-author-role=\"assistant\"]');
      for (let elem of messageElements) {
        const text = elem.textContent;
        if (text.includes('can\\'t create') || 
            text.includes('unable to generate') ||
            text.includes('cannot create') ||
            text.includes('violates our content policies') ||
            text.includes('request violates') ||
            text.includes('content policy') ||
            text.includes('You\\'ve hit the plus plan limit') ||
            text.includes('sorry') ||
            text.includes('unfortunately')) {
          return text.trim();
        }
      }
      return 'ChatGPT image generation error detected';
    }")
    
    // Zapisz komunikat błędu w właściwościach zadania
    mcp__todoit__todo_set_item_property(
      list_key: "[TODOIT_LIST]",
      item_key: next_task.key,
      property_key: "ERROR",
      property_value: error_message
    )
    
    // Wyciągnij thread ID nawet w przypadku błędu
    thread_id = mcp__playwright-headless__browser_evaluate(
      function: "() => { return window.location.pathname.split('/c/')[1]; }"
    )
    
    // Zapisz thread ID w właściwościach zadania
    mcp__todoit__todo_set_item_property(
      list_key: "[TODOIT_LIST]",
      item_key: next_task.key,
      property_key: "thread_id",
      property_value: thread_id
    )
    
    // Oznacz zadanie jako failed
    mcp__todoit__todo_update_item_status(
      list_key: "[TODOIT_LIST]",
      item_key: next_task.key,
      status: "failed"
    )
    
    // Raportuj błąd
    echo "BŁĄD: " + next_task.content + " - ChatGPT generation error. Thread ID: " + thread_id
    return

  8. Zapisanie thread ID i finalizacja zadania

  // Wyciągnij thread ID z URL
  thread_id = mcp__playwright-headless__browser_evaluate(
    function: "() => { return window.location.pathname.split('/c/')[1]; }"
  )

  // Zapisz thread ID w właściwościach zadania
  mcp__todoit__todo_set_item_property(
    list_key: "[TODOIT_LIST]",
    item_key: next_task.key,
    property_key: "thread_id",
    property_value: thread_id
  )

  // Oznacz zadanie jako completed
  mcp__todoit__todo_update_item_status(
    list_key: "[TODOIT_LIST]",
    item_key: next_task.key,
    status: "completed"
  )

  // Raportuj sukces
  echo "Zadanie " + next_task.content + " ukończone. Thread ID: " + thread_id

  Uwagi techniczne:

  - CRITICAL: Worker przetwarza TYLKO JEDNO zadanie na wywołanie
  - BOOK_FOLDER jest odczytywany z właściwości listy TODOIT
  - PROJECT_ID jest zapisywany w liście przy pierwszym utworzeniu projektu
  - Thread ID jest zapisywany w właściwościach każdego zadania
  - Worker kończy działanie po ukończeniu jednego zadania
  - Orchestrator 37d-c3 wywołuje worker w pętli dopóki są pending zadania
  - Nazwa projektu ChatGPT = BOOK_FOLDER (np. "0011_gullivers_travels")
  - CRITICAL: Używaj contenteditable div, NIE textarea dla promptu
  - Element refs są dynamiczne - zawsze rób snapshot przed interakcją

  Stan końcowy zadania:

  - Jedno zadanie przetworzone i oznaczone jako completed
  - Thread ID zapisany w właściwościach zadania
  - PROJECT_ID zapisany w właściwościach listy (przy pierwszym wywołaniu)
  - Obraz rozpoczął generowanie w ChatGPT z pełną specyfikacją YAML
  - Worker zakończył działanie - orchestrator może wywołać następne zadanie